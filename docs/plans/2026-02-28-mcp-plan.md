# MCP Server & Client Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add two registry components — `mcp-server` (expose kitn tools/agents via MCP protocol) and `mcp-client` (consume external MCP servers as tool sources).

**Architecture:** Two independent packages in the monorepo: `packages/adapters/mcp-server/` (adapter pattern) and `packages/mcp-client/` (standalone utility). Each is built as a `kitn:package` registry component — users install via `kitn add` and own the source. Protocol SDKs are npm dependencies.

**Tech Stack:** `@modelcontextprotocol/server` (MCP protocol), `@ai-sdk/mcp` (AI SDK MCP client), `@kitnai/core` (kitn engine), `zod` (schemas), `bun:test` (testing)

**Design doc:** `docs/plans/2026-02-28-mcp-design.md`

---

### Task 1: Scaffold MCP Server Package

**Files:**
- Create: `packages/adapters/mcp-server/package.json`
- Create: `packages/adapters/mcp-server/tsconfig.json`
- Create: `packages/adapters/mcp-server/src/index.ts`

**Step 1: Create package.json**

```json
{
  "name": "@kitnai/mcp-server-adapter",
  "version": "0.1.0",
  "type": "module",
  "description": "MCP server adapter for kitn — expose tools and agents via Model Context Protocol",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/kitn-ai/kitn",
    "directory": "packages/adapters/mcp-server"
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "files": ["dist"],
  "publishConfig": { "access": "public" },
  "scripts": {
    "build": "tsc",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "bun run build"
  },
  "peerDependencies": {
    "@modelcontextprotocol/server": "^2.0.0",
    "zod": "^4.0.0"
  },
  "dependencies": {
    "@kitnai/core": "workspace:*"
  },
  "devDependencies": {
    "@modelcontextprotocol/server": "^2.0.0",
    "@types/bun": "^1.3.9",
    "typescript": "^5.9.3",
    "zod": "^4.3.6"
  }
}
```

**Step 2: Create tsconfig.json**

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src"]
}
```

**Step 3: Create empty src/index.ts**

```ts
// MCP Server adapter — exports will be added as implementation progresses
```

**Step 4: Install dependencies**

Run: `bun install`
Expected: Resolves workspace and installs `@modelcontextprotocol/server`

**Step 5: Verify typecheck**

Run: `bun run --cwd packages/adapters/mcp-server typecheck`
Expected: PASS (empty file compiles)

**Step 6: Commit**

```bash
git add packages/adapters/mcp-server/
git commit -m "chore: scaffold mcp-server adapter package"
```

---

### Task 2: MCP Server Bridge Functions

**Files:**
- Create: `packages/adapters/mcp-server/src/bridge.ts`
- Create: `packages/adapters/mcp-server/test/bridge.test.ts`

**Step 1: Write the failing tests**

```ts
// test/bridge.test.ts
import { describe, test, expect } from "bun:test";
import { toolResultToMCP, toolErrorToMCP } from "../src/bridge.js";

describe("toolResultToMCP", () => {
  test("converts string result to text content", () => {
    const result = toolResultToMCP("hello");
    expect(result).toEqual({
      content: [{ type: "text", text: "hello" }],
    });
  });

  test("converts object result to JSON text content", () => {
    const result = toolResultToMCP({ temp: 72, unit: "F" });
    expect(result).toEqual({
      content: [{ type: "text", text: '{"temp":72,"unit":"F"}' }],
    });
  });

  test("converts number result to text content", () => {
    const result = toolResultToMCP(42);
    expect(result).toEqual({
      content: [{ type: "text", text: "42" }],
    });
  });

  test("converts null result to text content", () => {
    const result = toolResultToMCP(null);
    expect(result).toEqual({
      content: [{ type: "text", text: "null" }],
    });
  });
});

describe("toolErrorToMCP", () => {
  test("converts Error to error content", () => {
    const result = toolErrorToMCP(new Error("something broke"));
    expect(result).toEqual({
      isError: true,
      content: [{ type: "text", text: "something broke" }],
    });
  });

  test("converts string error to error content", () => {
    const result = toolErrorToMCP("bad input");
    expect(result).toEqual({
      isError: true,
      content: [{ type: "text", text: "bad input" }],
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `bun test packages/adapters/mcp-server/test/bridge.test.ts`
Expected: FAIL — module not found

**Step 3: Write the bridge implementation**

```ts
// src/bridge.ts

/** Convert a kitn tool execution result to MCP CallToolResult format. */
export function toolResultToMCP(result: unknown): { content: Array<{ type: "text"; text: string }> } {
  const text = typeof result === "string" ? result : JSON.stringify(result);
  return { content: [{ type: "text", text }] };
}

/** Convert an error to MCP error CallToolResult format. */
export function toolErrorToMCP(error: unknown): { isError: true; content: Array<{ type: "text"; text: string }> } {
  const message = error instanceof Error ? error.message : String(error);
  return { isError: true, content: [{ type: "text", text: message }] };
}
```

**Step 4: Run tests to verify they pass**

Run: `bun test packages/adapters/mcp-server/test/bridge.test.ts`
Expected: PASS (6 tests)

**Step 5: Commit**

```bash
git add packages/adapters/mcp-server/src/bridge.ts packages/adapters/mcp-server/test/
git commit -m "feat(mcp-server): add bridge functions for tool result conversion"
```

---

### Task 3: MCP Server Types

**Files:**
- Create: `packages/adapters/mcp-server/src/types.ts`

**Step 1: Write the types**

```ts
// src/types.ts

/** Configuration for createMCPServer(). */
export interface MCPServerConfig {
  /** Server name exposed to MCP clients. */
  name: string;

  /** Server version (default: "1.0.0"). */
  version?: string;

  /** Tool names to expose. If omitted, all registered tools are exposed. */
  tools?: string[];

  /** Agent names to expose as MCP tools. Each becomes a tool with a `message` input. */
  agents?: string[];
}
```

**Step 2: Verify typecheck**

Run: `bun run --cwd packages/adapters/mcp-server typecheck`
Expected: PASS

**Step 3: Commit**

```bash
git add packages/adapters/mcp-server/src/types.ts
git commit -m "feat(mcp-server): add MCPServerConfig type"
```

---

### Task 4: MCP Server Implementation

**Files:**
- Create: `packages/adapters/mcp-server/src/server.ts`
- Create: `packages/adapters/mcp-server/test/server.test.ts`
- Modify: `packages/adapters/mcp-server/src/index.ts`

**Context:** The `McpServer` from `@modelcontextprotocol/server` provides `registerTool()`. kitn's `PluginContext` provides `tools.list()`, `tools.execute()`, `agents.get()`, and `executeTask()` from `@kitnai/core`. The `StdioServerTransport` comes from `@modelcontextprotocol/server`.

**Step 1: Write the failing tests**

```ts
// test/server.test.ts
import { describe, test, expect, mock } from "bun:test";
import { z } from "zod";
import { createMCPServer } from "../src/server.js";

// Minimal mock PluginContext
function createMockContext(overrides: Record<string, any> = {}) {
  return {
    tools: {
      list: () => overrides.tools ?? [],
      execute: overrides.execute ?? mock(() => Promise.resolve("ok")),
    },
    agents: {
      get: (name: string) => (overrides.agents ?? {})[name],
    },
    ...overrides,
  } as any;
}

describe("createMCPServer", () => {
  test("returns server object with server property and connectStdio method", () => {
    const ctx = createMockContext();
    const mcp = createMCPServer(ctx, { name: "test-server" });
    expect(mcp.server).toBeDefined();
    expect(typeof mcp.connectStdio).toBe("function");
  });

  test("registers all tools when no filter specified", () => {
    const ctx = createMockContext({
      tools: [
        { name: "getWeather", description: "Get weather", inputSchema: z.object({ location: z.string() }) },
        { name: "calculate", description: "Calculate", inputSchema: z.object({ expr: z.string() }) },
      ],
    });
    const mcp = createMCPServer(ctx, { name: "test-server" });
    // McpServer doesn't expose a list of registered tools,
    // so we verify it was created without errors
    expect(mcp.server).toBeDefined();
  });

  test("filters tools when tools array specified", () => {
    const ctx = createMockContext({
      tools: [
        { name: "getWeather", description: "Get weather", inputSchema: z.object({ location: z.string() }) },
        { name: "calculate", description: "Calculate", inputSchema: z.object({ expr: z.string() }) },
      ],
    });
    // Should not throw even though "calculate" is excluded
    const mcp = createMCPServer(ctx, { name: "test-server", tools: ["getWeather"] });
    expect(mcp.server).toBeDefined();
  });

  test("registers agents as MCP tools when agents specified", () => {
    const ctx = createMockContext({
      agents: {
        general: { name: "general", description: "General assistant" },
      },
    });
    const mcp = createMCPServer(ctx, { name: "test-server", agents: ["general"] });
    expect(mcp.server).toBeDefined();
  });

  test("skips agents that are not registered", () => {
    const ctx = createMockContext({ agents: {} });
    // Should not throw for unknown agents
    const mcp = createMCPServer(ctx, { name: "test-server", agents: ["nonexistent"] });
    expect(mcp.server).toBeDefined();
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `bun test packages/adapters/mcp-server/test/server.test.ts`
Expected: FAIL — module not found

**Step 3: Write the server implementation**

```ts
// src/server.ts
import { McpServer } from "@modelcontextprotocol/server";
import { z } from "zod";
import type { PluginContext } from "@kitnai/core";
import { executeTask } from "@kitnai/core";
import type { MCPServerConfig } from "./types.js";
import { toolResultToMCP, toolErrorToMCP } from "./bridge.js";

export function createMCPServer(ctx: PluginContext, config: MCPServerConfig) {
  const server = new McpServer({
    name: config.name,
    version: config.version ?? "1.0.0",
  });

  // Register tools
  const allTools = ctx.tools.list();
  const tools = config.tools
    ? allTools.filter((t) => config.tools!.includes(t.name))
    : allTools;

  for (const tool of tools) {
    server.registerTool(tool.name, {
      description: tool.description,
      inputSchema: tool.inputSchema,
    }, async (input) => {
      try {
        const result = await ctx.tools.execute(tool.name, input);
        return toolResultToMCP(result);
      } catch (error) {
        return toolErrorToMCP(error);
      }
    });
  }

  // Register agents as MCP tools
  if (config.agents) {
    for (const agentName of config.agents) {
      const agent = ctx.agents.get(agentName);
      if (!agent) continue;

      server.registerTool(`agent:${agentName}`, {
        description: agent.description ?? `Chat with the ${agentName} agent`,
        inputSchema: z.object({
          message: z.string().describe("Message to send to the agent"),
        }),
      }, async ({ message }) => {
        try {
          const result = await executeTask(ctx, agentName, message);
          return toolResultToMCP(result.result.response);
        } catch (error) {
          return toolErrorToMCP(error);
        }
      });
    }
  }

  return {
    /** The underlying McpServer instance for custom transport wiring. */
    server,

    /** Connect via stdio transport (for Claude Desktop, Cursor, etc.). */
    async connectStdio() {
      const { StdioServerTransport } = await import("@modelcontextprotocol/server");
      const transport = new StdioServerTransport();
      await server.connect(transport);
    },
  };
}
```

**Important notes for the implementer:**
- `executeTask` must be exported from `@kitnai/core`. Check `packages/core/src/index.ts` — if it's not exported, add it.
- The `StdioServerTransport` is dynamically imported so it doesn't fail in browser/non-Node environments.
- `tool.inputSchema` from kitn is a Zod schema, which `McpServer.registerTool()` accepts directly.

**Step 4: Update src/index.ts with exports**

```ts
// src/index.ts
export { createMCPServer } from "./server.js";
export type { MCPServerConfig } from "./types.js";
export { toolResultToMCP, toolErrorToMCP } from "./bridge.js";
```

**Step 5: Run tests to verify they pass**

Run: `bun test packages/adapters/mcp-server/test/server.test.ts`
Expected: PASS (5 tests)

**Note:** If `executeTask` is not exported from `@kitnai/core`, add it to `packages/core/src/index.ts`. Check by grepping: `grep "executeTask" packages/core/src/index.ts`. If missing, add: `export { executeTask } from "./agents/execute-task.js";`

**Step 6: Verify full typecheck**

Run: `bun run --cwd packages/adapters/mcp-server typecheck`
Expected: PASS

**Step 7: Commit**

```bash
git add packages/adapters/mcp-server/
git commit -m "feat(mcp-server): implement createMCPServer with tool and agent registration"
```

---

### Task 5: MCP Server Registry Component

**Files:**
- Create: `registry/components/package/adapters/mcp-server/manifest.json`
- Modify: `registry/scripts/build-registry.ts` (add to PACKAGE_IMPORT_REWRITES)

**Step 1: Create the registry manifest**

```json
{
  "name": "mcp-server",
  "type": "kitn:package",
  "description": "MCP server adapter — expose kitn tools and agents via Model Context Protocol",
  "sourceDir": "packages/adapters/mcp-server/src",
  "installDir": "adapters/mcp-server",
  "dependencies": ["@modelcontextprotocol/server"],
  "registryDependencies": ["core"],
  "docs": "Expose your kitn tools as an MCP server:\n\n  import { createMCPServer } from '@kitn/adapters/mcp-server';\n  const mcp = createMCPServer(plugin, { name: 'my-server' });\n  await mcp.connectStdio();\n\nSee src/ai/adapters/mcp-server/server.ts for configuration options.",
  "version": "1.0.0",
  "changelog": [
    { "version": "1.0.0", "date": "2026-02-28", "type": "initial", "note": "Initial release — tool and agent exposure via MCP" }
  ]
}
```

**Step 2: Add import rewrite to build-registry.ts**

Open `registry/scripts/build-registry.ts` and find the `PACKAGE_IMPORT_REWRITES` map (or equivalent). Add:

```ts
"@kitnai/mcp-server-adapter": "@kitn/adapters/mcp-server",
```

This is next to the existing entries like `"@kitnai/hono-adapter": "@kitn/adapters/hono"`.

**Step 3: Verify registry builds**

Run: `bun run --cwd registry build`
Expected: Should now include `✓ Built package/mcp-server.json` in output

**Step 4: Commit**

```bash
git add registry/components/package/adapters/mcp-server/ registry/scripts/build-registry.ts
git commit -m "feat(registry): add mcp-server package component"
```

---

### Task 6: Scaffold MCP Client Package

**Files:**
- Create: `packages/mcp-client/package.json`
- Create: `packages/mcp-client/tsconfig.json`
- Create: `packages/mcp-client/src/index.ts`

**Step 1: Create package.json**

```json
{
  "name": "@kitnai/mcp-client",
  "version": "0.1.0",
  "type": "module",
  "description": "MCP client for kitn — consume external MCP servers as tool sources",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/kitn-ai/kitn",
    "directory": "packages/mcp-client"
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "files": ["dist"],
  "publishConfig": { "access": "public" },
  "scripts": {
    "build": "tsc",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "bun run build"
  },
  "peerDependencies": {
    "@ai-sdk/mcp": "^0.1.0",
    "zod": "^4.0.0"
  },
  "dependencies": {
    "@kitnai/core": "workspace:*"
  },
  "devDependencies": {
    "@ai-sdk/mcp": "^0.1.0",
    "@types/bun": "^1.3.9",
    "typescript": "^5.9.3",
    "zod": "^4.3.6"
  }
}
```

**Note:** Check the latest `@ai-sdk/mcp` version on npm before writing this file. The `^0.1.0` is a placeholder — use whatever the current version is.

**Step 2: Create tsconfig.json**

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src"]
}
```

Note: Two levels up (`../../tsconfig.json`) because this is `packages/mcp-client/`, not under `packages/adapters/`.

**Step 3: Create empty src/index.ts**

```ts
// MCP Client — exports will be added as implementation progresses
```

**Step 4: Install dependencies**

Run: `bun install`
Expected: Resolves workspace and installs `@ai-sdk/mcp`

**Step 5: Verify typecheck**

Run: `bun run --cwd packages/mcp-client typecheck`
Expected: PASS

**Step 6: Commit**

```bash
git add packages/mcp-client/
git commit -m "chore: scaffold mcp-client package"
```

---

### Task 7: MCP Client Types

**Files:**
- Create: `packages/mcp-client/src/types.ts`

**Step 1: Write the types**

```ts
// src/types.ts
import type { createMCPClient } from "@ai-sdk/mcp";

/** Configuration for a single MCP server connection. */
export interface ServerConfig {
  /** Unique name for this server (used as tool namespace prefix). */
  name: string;

  /** Transport configuration. */
  transport:
    | { type: "http"; url: string; headers?: Record<string, string> }
    | { type: "sse"; url: string; headers?: Record<string, string> }
    | { type: "stdio"; command: string; args?: string[] };
}

/** Configuration for connectMCPServers(). */
export interface MCPClientConfig {
  /** List of MCP servers to connect to. */
  servers: ServerConfig[];
}

/** Return value from connectMCPServers(). */
export interface MCPConnection {
  /** Connected MCP clients, keyed by server name. */
  clients: Map<string, Awaited<ReturnType<typeof createMCPClient>>>;

  /** Re-discover and re-register tools from one or all servers. */
  refresh: (serverName?: string) => Promise<void>;

  /** Disconnect all MCP clients. Call on shutdown. */
  close: () => Promise<void>;
}
```

**Step 2: Verify typecheck**

Run: `bun run --cwd packages/mcp-client typecheck`
Expected: PASS

**Step 3: Commit**

```bash
git add packages/mcp-client/src/types.ts
git commit -m "feat(mcp-client): add MCPClientConfig and MCPConnection types"
```

---

### Task 8: MCP Client Implementation

**Files:**
- Create: `packages/mcp-client/src/client.ts`
- Create: `packages/mcp-client/test/client.test.ts`
- Modify: `packages/mcp-client/src/index.ts`

**Context:** `createMCPClient` from `@ai-sdk/mcp` accepts a `transport` config and returns a client with a `tools()` method that returns AI SDK-compatible tool objects. We register these into kitn's `ToolRegistry` with namespaced names.

**Step 1: Write the failing tests**

```ts
// test/client.test.ts
import { describe, test, expect, mock, beforeEach } from "bun:test";
import { z } from "zod";

// We can't easily mock @ai-sdk/mcp in bun, so test the internal helpers
import { namespaceTool, buildToolRegistration } from "../src/client.js";

describe("namespaceTool", () => {
  test("prefixes tool name with server name", () => {
    expect(namespaceTool("github", "createIssue")).toBe("github:createIssue");
  });
});

describe("buildToolRegistration", () => {
  test("creates a ToolRegistration from an MCP tool", () => {
    const mcpTool = {
      description: "Create an issue",
      parameters: z.object({ title: z.string() }),
      execute: mock(() => Promise.resolve({ text: "done" })),
    };

    const reg = buildToolRegistration("github", "createIssue", mcpTool);
    expect(reg.name).toBe("github:createIssue");
    expect(reg.description).toBe("[github] Create an issue");
    expect(reg.inputSchema).toBe(mcpTool.parameters);
    expect(reg.tool).toBeDefined();
  });

  test("uses tool name as description fallback", () => {
    const mcpTool = {
      parameters: z.object({}),
      execute: mock(() => Promise.resolve({})),
    };

    const reg = buildToolRegistration("db", "query", mcpTool);
    expect(reg.description).toBe("[db] query");
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `bun test packages/mcp-client/test/client.test.ts`
Expected: FAIL — module not found

**Step 3: Write the client implementation**

```ts
// src/client.ts
import { createMCPClient } from "@ai-sdk/mcp";
import type { PluginContext, ToolRegistration } from "@kitnai/core";
import type { MCPClientConfig, MCPConnection, ServerConfig } from "./types.js";

/** Create a namespaced tool name: "serverName:toolName". */
export function namespaceTool(serverName: string, toolName: string): string {
  return `${serverName}:${toolName}`;
}

/** Build a kitn ToolRegistration from an MCP tool. */
export function buildToolRegistration(
  serverName: string,
  toolName: string,
  mcpTool: any,
): ToolRegistration {
  return {
    name: namespaceTool(serverName, toolName),
    description: `[${serverName}] ${mcpTool.description ?? toolName}`,
    inputSchema: mcpTool.parameters,
    tool: mcpTool,
  };
}

/** Connect to one MCP server and register its tools. */
async function connectServer(
  ctx: PluginContext,
  config: ServerConfig,
): Promise<Awaited<ReturnType<typeof createMCPClient>>> {
  const client = await createMCPClient({ transport: config.transport as any });
  const tools = await client.tools();

  for (const [toolName, tool] of Object.entries(tools)) {
    ctx.tools.register(buildToolRegistration(config.name, toolName, tool));
  }

  return client;
}

/**
 * Connect to external MCP servers and register their tools into kitn's ToolRegistry.
 *
 * Tools are namespaced by server name to prevent collisions:
 * - `github:createIssue`, `github:listPRs`
 * - `database:query`, `database:listTables`
 */
export async function connectMCPServers(
  ctx: PluginContext,
  config: MCPClientConfig,
): Promise<MCPConnection> {
  const clients = new Map<string, Awaited<ReturnType<typeof createMCPClient>>>();

  for (const server of config.servers) {
    const client = await connectServer(ctx, server);
    clients.set(server.name, client);
  }

  return {
    clients,

    async refresh(serverName?: string) {
      const targets = serverName
        ? config.servers.filter((s) => s.name === serverName)
        : config.servers;

      for (const server of targets) {
        const client = clients.get(server.name);
        if (!client) continue;

        const tools = await client.tools();
        for (const [toolName, tool] of Object.entries(tools)) {
          ctx.tools.register(buildToolRegistration(server.name, toolName, tool));
        }
      }
    },

    async close() {
      await Promise.all(
        Array.from(clients.values()).map((c) => c.close()),
      );
      clients.clear();
    },
  };
}
```

**Step 4: Update src/index.ts with exports**

```ts
// src/index.ts
export { connectMCPServers, namespaceTool, buildToolRegistration } from "./client.js";
export type { MCPClientConfig, MCPConnection, ServerConfig } from "./types.js";
```

**Step 5: Run tests to verify they pass**

Run: `bun test packages/mcp-client/test/client.test.ts`
Expected: PASS (3 tests)

**Step 6: Verify full typecheck**

Run: `bun run --cwd packages/mcp-client typecheck`
Expected: PASS

**Note:** If TypeScript complains about `createMCPClient` transport type, cast with `as any` — the AI SDK's transport union type may not exactly match our `ServerConfig.transport` shape, but it works at runtime. The user owns the source and can refine types.

**Step 7: Commit**

```bash
git add packages/mcp-client/
git commit -m "feat(mcp-client): implement connectMCPServers with tool discovery and registration"
```

---

### Task 9: MCP Client Registry Component

**Files:**
- Create: `registry/components/package/mcp-client/manifest.json`
- Modify: `registry/scripts/build-registry.ts` (add to PACKAGE_IMPORT_REWRITES)

**Step 1: Create the registry manifest**

```json
{
  "name": "mcp-client",
  "type": "kitn:package",
  "description": "MCP client — consume external MCP servers as tool sources for kitn agents",
  "sourceDir": "packages/mcp-client/src",
  "installDir": "mcp-client",
  "dependencies": ["@ai-sdk/mcp"],
  "registryDependencies": ["core"],
  "docs": "Connect to external MCP servers:\n\n  import { connectMCPServers } from '@kitn/mcp-client';\n  const mcp = await connectMCPServers(plugin, {\n    servers: [{ name: 'github', transport: { type: 'http', url: '...' } }],\n  });\n\nMCP tools are registered with namespaced names (e.g. github:createIssue).\nSee src/ai/mcp-client/client.ts for configuration options.",
  "version": "1.0.0",
  "changelog": [
    { "version": "1.0.0", "date": "2026-02-28", "type": "initial", "note": "Initial release — connect to MCP servers and register tools" }
  ]
}
```

**Step 2: Add import rewrite to build-registry.ts**

In the same `PACKAGE_IMPORT_REWRITES` map, add:

```ts
"@kitnai/mcp-client": "@kitn/mcp-client",
```

**Step 3: Verify registry builds**

Run: `bun run --cwd registry build`
Expected: Should now include both `✓ Built package/mcp-server.json` and `✓ Built package/mcp-client.json`

**Step 4: Commit**

```bash
git add registry/components/package/mcp-client/ registry/scripts/build-registry.ts
git commit -m "feat(registry): add mcp-client package component"
```

---

### Task 10: Full Verification

**Step 1: Build all packages**

Run: `bun run build`
Expected: All packages build successfully including new mcp-server and mcp-client

**Step 2: Typecheck all packages**

Run: `bun run typecheck`
Expected: All 12 packages (10 existing + 2 new) pass typecheck

**Step 3: Run all tests**

Run: `bun run test`
Expected: All tests pass including new bridge and client tests

**Step 4: Rebuild registry**

Run: `bun run --cwd registry build`
Expected: 37 components (35 existing + 2 new: `package/mcp-server.json`, `package/mcp-client.json`)

**Step 5: Verify clean working tree**

Run: `git status`
Expected: Only the registry output files (if not gitignored) or clean

**Step 6: Final commit if needed**

If registry output changed:
```bash
git add registry/r/
git commit -m "chore: rebuild registry with mcp-server and mcp-client components"
```
